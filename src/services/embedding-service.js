import { HuggingFaceInferenceEmbeddings } from "@langchain/community/embeddings/hf";

export class EmbeddingService {
  constructor() {
    this.embeddings = null;
    this.isInitialized = false;
  }

  /**
   * Initialize the embedding service
   * @returns {Promise<boolean>} Success status
   */
  async initialize() {
    try {
      const apiKey = process.env.HF_API_KEY;
      if (!apiKey) {
        throw new Error("HF_API_KEY environment variable is required");
      }

      const model = process.env.HF_MODEL || "sentence-transformers/all-MiniLM-L6-v2";

      this.embeddings = new HuggingFaceInferenceEmbeddings({
        model: model,
        apiKey: apiKey,
      });

      // Test the connection directly (bypass isInitialized check during init)
      console.log("üîç Testing embedding service connection...");
      const testEmbedding = await this.embeddings.embedQuery("test");
      console.log(`‚úÖ Test embedding generated with ${testEmbedding.length} dimensions`);

      this.isInitialized = true;
      console.log(`‚úÖ Embedding service initialized with model: ${model}`);
      return true;
    } catch (error) {
      console.error("‚ùå Embedding service initialization failed:", error);
      throw new Error(`Failed to initialize embedding service: ${error.message}`);
    }
  }

  /**
   * Generate embeddings for multiple texts
   * @param {string[]} texts - Array of texts to embed
   * @returns {Promise<number[][]>} Array of embeddings
   */
  async generateEmbeddings(texts) {
    try {
      if (!this.isInitialized || !this.embeddings) {
        throw new Error("Embedding service not initialized");
      }

      if (!texts || texts.length === 0) {
        throw new Error("No texts provided for embedding");
      }

      console.log(`ü§ñ Generating embeddings for ${texts.length} texts...`);
      const embeddings = await this.embeddings.embedDocuments(texts);
      console.log(`‚úÖ Generated ${embeddings.length} embeddings`);

      return embeddings;
    } catch (error) {
      console.error("‚ùå Embedding generation failed:", error);
      throw new Error(`Failed to generate embeddings: ${error.message}`);
    }
  }

  /**
   * Generate embedding for a single text
   * @param {string} text - Text to embed
   * @returns {Promise<number[]>} Single embedding vector
   */
  async generateSingleEmbedding(text) {
    try {
      if (!this.isInitialized || !this.embeddings) {
        throw new Error("Embedding service not initialized");
      }

      if (!text || text.trim().length === 0) {
        throw new Error("No text provided for embedding");
      }

      console.log("üîç Generating single embedding...");
      const embedding = await this.embeddings.embedQuery(text);
      console.log(`‚úÖ Generated embedding with ${embedding.length} dimensions`);

      return embedding;
    } catch (error) {
      console.error("‚ùå Single embedding generation failed:", error);
      throw new Error(`Failed to generate single embedding: ${error.message}`);
    }
  }

  /**
   * Generate embeddings in batches to handle large datasets
   * @param {string[]} texts - Array of texts to embed
   * @param {number} batchSize - Size of each batch
   * @returns {Promise<number[][]>} Array of embeddings
   */
  async generateEmbeddingsBatch(texts, batchSize = 50) {
    try {
      if (!this.isInitialized || !this.embeddings) {
        throw new Error("Embedding service not initialized");
      }

      if (!texts || texts.length === 0) {
        return [];
      }

      console.log(`üîÑ Generating embeddings in batches of ${batchSize}...`);
      const allEmbeddings = [];

      for (let i = 0; i < texts.length; i += batchSize) {
        const batch = texts.slice(i, i + batchSize);
        console.log(`üì¶ Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(texts.length/batchSize)}`);

        const batchEmbeddings = await this.generateEmbeddings(batch);
        allEmbeddings.push(...batchEmbeddings);
      }

      console.log(`‚úÖ Generated ${allEmbeddings.length} embeddings in ${Math.ceil(texts.length/batchSize)} batches`);
      return allEmbeddings;
    } catch (error) {
      console.error("‚ùå Batch embedding generation failed:", error);
      throw new Error(`Failed to generate batch embeddings: ${error.message}`);
    }
  }

  /**
   * Get the dimensions of embeddings generated by this service
   * @returns {Promise<number>} Embedding dimensions
   */
  async getEmbeddingDimensions() {
    try {
      if (!this.isInitialized || !this.embeddings) {
        throw new Error("Embedding service not initialized");
      }

      const testEmbedding = await this.generateSingleEmbedding("test");
      return testEmbedding.length;
    } catch (error) {
      console.error("‚ùå Failed to get embedding dimensions:", error);
      throw new Error(`Failed to get embedding dimensions: ${error.message}`);
    }
  }

  /**
   * Check if the service is healthy
   * @returns {Promise<boolean>} Health status
   */
  async healthCheck() {
    try {
      if (!this.isInitialized) {
        return false;
      }

      // Quick health check by generating a small embedding
      await this.generateSingleEmbedding("health check");
      return true;
    } catch (error) {
      console.error("‚ùå Embedding service health check failed:", error);
      return false;
    }
  }
}

export default EmbeddingService;
